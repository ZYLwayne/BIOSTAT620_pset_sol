---
title: Problem set 7
date: 2025-03-15
execute: 
  eval: true
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(error = TRUE)
```
1. Load the **HistData** package. Create a `galton_height` data with the father's height and one randomly selected daughter from each family. Exclude families with no female children. Set the seed at 2007 and use the function `sample_n` to select the random child. You should end up with a `heights` dataset with two columns: `father` and `daughter`.


```{r}
library(HistData)
library(dplyr)
names(GaltonFamilies)

set.seed(2007)
heights <- GaltonFamilies %>%
  filter(gender == "female") %>%
  group_by(family) %>%                    
  sample_n(1) %>%                          
  ungroup() %>%
  select(father, daughter = childHeight)   

head(heights)
```

2. Estimate the intercept and slope of the regression line for predicting daughter height $Y$ using father height $X$. Use the following regression line formula:

$$
\frac{\hat{Y} - \mu_Y}{\sigma_Y} = \rho \frac{x - \mu_x}{\sigma_x} 
$$

```{r}
mu_x <- mean(heights$father)
mu_y <- mean(heights$daughter)
sigma_x <- sd(heights$father)
sigma_y <- sd(heights$daughter)

# Calculate the correlation coefficient
rho <- cor(heights$father, heights$daughter)

# Calculate regression coefficients
beta_1 <- rho * (sigma_y / sigma_x)
beta_0 <- mu_y - beta_1 * mu_x

# Parameters of the output regression equation
cat("Intercept (β0):", beta_0, "\n")
cat("Slope (β1):", beta_1, "\n")
```

3. Make a plot to confirm the regression line goes through the data.

```{r}
library(ggplot2)

ggplot(heights, aes(x = father, y = daughter)) +
  geom_point(color = "blue", alpha = 0.6) +  
  geom_smooth(method = "lm", color = "red", se = FALSE) +  
  labs(title = "Father vs Daughter Height Regression",
       x = "Father's Height",
       y = "Daughter's Height") +
  theme_minimal()

```

4. Recompute the slope and intercept coefficients, this time using `lm` and confirm you get the same answer as with the formula used in problem 2.

```{r}
# Calculate the regression model using lm()
model <- lm(daughter ~ father, data = heights)

# Output the regression coefficients
summary(model)

beta_0_lm <- coef(model)[1]  
beta_1_lm <- coef(model)[2]  

cat("Intercept (β0) from lm():", beta_0_lm, "\n")
cat("Slope (β1) from lm():", beta_1_lm, "\n")
```

5. Note that the interpretation of the intercept is: the height prediction for the daughter whose father is 0 inches tall. This is not a very useful interpretation. Re-run the regression but instead of father height use inches above average for each father: instead of using the $x_i$s use $x_i - \bar{x}$. What is the interpretation of the intercept now? Does the slope estimate change?

```{r}
heights <- heights %>%
  mutate(father_centered = father - mean(father))

model_centered <- lm(daughter ~ father_centered, data = heights)

summary(model_centered)

beta_0_centered <- coef(model_centered)[1]  
beta_1_centered <- coef(model_centered)[2]  

cat("Intercept (β0) with centered father heights:", beta_0_centered, "\n")
cat("Slope (β1) with centered father heights:", beta_1_centered, "\n")

```

6. When using the centered father heights as a predictor, is the intercept the same as the average daughter height? Check if this is the case with the values you computed and then show that mathematically this has to be the case.

```{r}
mu_y <- mean(heights$daughter)

cat("Mean daughter height:", mu_y, "\n")
cat("Intercept from centered regression:", beta_0_centered, "\n")

all.equal(beta_0_centered, mu_y)
```

For the next exercises install the **excessmort** package. For the latest version use

```{r}
#| eval: false
library(devtools)
install_github("rafalab/excessmort")
```


7. Define an object `counts` by wrangling `puerto_rico_counts` to 1) include data only from 2002-2017 and counts for people 60 or over. We will focus in this older subset throughout the rest of the problem set.

```{r}
library(excessmort)
library(dplyr)
library(lubridate)

head(puerto_rico_counts)

puerto_rico_counts <- puerto_rico_counts %>%
  mutate(year = year(date))  

unique(puerto_rico_counts$agegroup)

filtered_counts <- puerto_rico_counts %>%
  filter(year >= 2002 & year <= 2017, 
         agegroup %in% c("60-64", "65-69", "70-74", "75-79", "80-84", "85-Inf"))

head(filtered_counts)
```



8. Use R to determine what day of the week María made landfall in PR (September 20, 2017).

```{r}
landfall_date <- as.Date("2017-09-20")

day_of_week <- weekdays(landfall_date)
cat("Hurricane Maria made landfall in Puerto Rico on a", day_of_week, "\n")

```


10. Redefine the date column to be the start of the week that date is part of: in other words, round the date down to the nearest week. Use the day of the week María made landfall as the first day. So, for example, 2017-09-20, 2017-09-21, 2017-09-22 should all be rounded down to 2017-09-20, while 2017-09-19 should be rounded down to 2017-09-13. Save the resulting table in `weekly_counts`.


```{r}
library(lubridate)
library(dplyr)

weekly_counts <- puerto_rico_counts %>%
  mutate(week_start = date - (wday(date) - 4) %% 7)  

head(weekly_counts)
```

11. Now collapse the `weekly_count` data frame to store only one mortality value for each week, for each `sex` and `agegroup`. To this by by redefining `outcome` to have the total deaths that week for each `sex` and `agegroup`. Remove weeks that have less the 7 days of data. Finally, add a column with the MMWR week. Name the resulting data frame `weekly_counts`. 

```{r}
library(MMWRweek)

colnames(weekly_counts)
weekly_counts <- weekly_counts %>%
  group_by(week_start, sex, agegroup) %>%
  summarise(weekly_outcome = sum(outcome),  
            days_counted = n(),  
            .groups = "drop") %>%
  filter(days_counted == 7)  

weekly_counts <- weekly_counts %>%
  mutate(MMWR_year = year(week_start),
         MMWR_week = MMWRweek(week_start)$MMWRweek)

head(weekly_counts)
```


12. Comparing mortality totals is often unfair because the two groups begin compared have different population sizes. It is particularly important we consider rates rather than totals in this dataset because the demographics in Puerto Rico changed dramatically in the last 20 years. To see this use `puerto_rico_counts` to plot the population sizes by age group and gender. Provide a two sentence description of what you see.

```{r}
library(ggplot2)
library(dplyr)

puerto_rico_counts %>%
  ggplot(aes(x = agegroup, y = population, fill = sex)) +
  geom_boxplot(alpha = 0.7) +
  scale_y_log10() +  
  labs(title = "Population Size Distribution by Age Group and Gender",
       x = "Age Group",
       y = "Population (log scale)") +
  theme_minimal()
```



13. Make a boxplot for each MMWR week's mortality rate based on the 2002-2016 data. Each week has 15 data points, one for each year. Then add the 2017 data as red points. 


```{r}
weekly_counts <- puerto_rico_counts %>%
  mutate(week_start = date - (wday(date) - 4) %% 7) %>%
  group_by(week_start, sex, agegroup) %>%
  summarise(
    weekly_outcome = sum(outcome, na.rm = TRUE), 
    population = mean(population, na.rm = TRUE),  
    days_counted = n(), 
    .groups = "drop"
  ) %>%
  filter(days_counted == 7) 

weekly_counts <- weekly_counts %>%
  mutate(MMWR_year = MMWRweek(week_start)$MMWRyear,
         MMWR_week = MMWRweek(week_start)$MMWRweek)

colnames(weekly_counts)
head(weekly_counts)

weekly_counts <- weekly_counts %>%
  mutate(mortality_rate = weekly_outcome / population)  

weekly_counts_pre2017 <- weekly_counts %>%
  filter(MMWR_year >= 2002 & MMWR_year <= 2016)

weekly_counts_2017 <- weekly_counts %>%
  filter(MMWR_year == 2017)

ggplot(weekly_counts_pre2017, aes(x = as.factor(MMWR_week), y = mortality_rate)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +  
  geom_jitter(data = weekly_counts_2017, aes(x = as.factor(MMWR_week), y = mortality_rate),
              color = "red", size = 1.5, alpha = 0.7) +  
  labs(title = "Weekly Mortality Rate Distribution (2002-2016) with 2017 Data",
       x = "MMWR Week",
       y = "Mortality Rate") +
  theme_minimal()

```


14. Note two things: 1) there is a strong week effect and 2) 2017 is lower than expected. Plot the yearly rates (per 1,000)  for 2002-2016:

```{r}
yearly_counts <- weekly_counts %>%
  filter(MMWR_year >= 2002 & MMWR_year <= 2016) %>%
  group_by(MMWR_year) %>%
  summarise(
    total_deaths = sum(weekly_outcome, na.rm = TRUE),  
    total_population = sum(population, na.rm = TRUE),  
    mortality_rate = (total_deaths / total_population) * 1000  
  )

ggplot(yearly_counts, aes(x = MMWR_year, y = mortality_rate)) +
  geom_line(color = "blue", linewidth = 1) +  
  geom_point(size = 3, color = "red") +  
  labs(title = "Yearly Mortality Rate (per 1,000) for 2002-2016",
       x = "Year",
       y = "Mortality Rate (per 1,000)") +
  theme_minimal()
```

15. The plot made in 14 explains why 2017 is below what is expected: there appears to be a general decrease in mortality with time. A possible explanation is that medical care is improving and people are living more healthy lives.

Fit a linear model to the weekly data for the 65 and older to the 2002-2016 data that accounts for: 

* A changing population.
* The trend observed in 12.
* The week effect.
* Age effect.
* A sex effect.

Use rate as the outcome in the model.

```{r}
weekly_counts_65plus <- weekly_counts %>%
  filter(MMWR_year >= 2002 & MMWR_year <= 2016, agegroup %in% c("65-69", "70-74", "75-79", "80-84", "85-Inf")) %>%
  mutate(
    mortality_rate = weekly_outcome / population, 
    MMWR_week = as.factor(MMWR_week),  
    sex = as.factor(sex),  
    agegroup = as.factor(agegroup)
  )

model <- lm(mortality_rate ~ MMWR_year + MMWR_week + agegroup + sex, data = weekly_counts_65plus)

summary(model)
```


16. Now obtain expected counts for the entire dataset, including 2017. Compute the difference between the observed count and expected count and plot the total excess death for each week. Construct a confidence interval for the excess mortality estimate for each week. Hint: use the `predict` function.

```{r}

weekly_counts_2017 <- weekly_counts %>%
  filter(MMWR_year == 2017) %>%  
  filter(agegroup %in% c("65-69", "70-74", "75-79", "80-84", "85-Inf")) %>%  
  mutate(
    agegroup = factor(agegroup, levels = levels(weekly_counts$agegroup)), 
    MMWR_week = factor(MMWR_week) 
  )
predictions_2017 <- predict(model, newdata = weekly_counts_2017, interval = "confidence", level = 0.95)

weekly_counts_2017 <- weekly_counts_2017 %>%
  mutate(
    predicted_rate = predictions_2017[, "fit"], 
    lower_CI = predictions_2017[, "lwr"], 
    upper_CI = predictions_2017[, "upr"], 
    excess_mortality = mortality_rate - predicted_rate  
  )

weekly_counts_2017 <- weekly_counts_2017 %>%
  filter(!is.na(excess_mortality))

ggplot(weekly_counts_2017, aes(x = week_start, y = excess_mortality)) +
  geom_line(color = "red", size = 1) +  
  geom_ribbon(aes(ymin = lower_CI - predicted_rate, ymax = upper_CI - predicted_rate), 
              fill = "gray80", alpha = 0.5) + 
  labs(title = "Weekly Excess Mortality in 2017",
       x = "Week",
       y = "Excess Mortality Rate") +
  theme_minimal()
```
  
17. Finally, plot the observed rates and predicted rates from the model for each `agegroup` and `sex`. Comment on how well the model fits and what you might do differently.

```{r}
weekly_counts_pre2017 <- weekly_counts %>%
  filter(MMWR_year >= 2002 & MMWR_year <= 2016) %>%
  filter(agegroup %in% c("65-69", "70-74", "75-79", "80-84", "85-Inf")) %>%  
  mutate(
    agegroup = factor(agegroup, levels = levels(weekly_counts$agegroup)),
    MMWR_week = factor(MMWR_week) 
  )
predictions_pre2017 <- predict(model, newdata = weekly_counts_pre2017, interval = "confidence", level = 0.95)

weekly_counts_pre2017 <- weekly_counts_pre2017 %>%
  mutate(predicted_rate = predictions_pre2017[, "fit"])

all_data <- bind_rows(weekly_counts_pre2017, weekly_counts_2017)

all_data <- all_data %>%
  filter(!is.na(predicted_rate) & !is.na(mortality_rate))

ggplot(all_data, aes(x = predicted_rate, y = mortality_rate, color = agegroup)) +
  geom_point(alpha = 0.6) + 
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  labs(title = "Observed vs Predicted Mortality Rate (2002-2017)",
       x = "Predicted Mortality Rate",
       y = "Observed Mortality Rate") +
  theme_minimal()

ggplot(all_data, aes(x = predicted_rate, y = mortality_rate, color = sex)) +
  geom_point(alpha = 0.6) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  labs(title = "Observed vs Predicted Mortality Rate by Sex (2002-2017)",
       x = "Predicted Mortality Rate",
       y = "Observed Mortality Rate") +
  theme_minimal()
```